{"version":3,"file":"jsonLogic.min.js","sources":["../src/operations/arithmetic/add.js","../src/operations/arithmetic/multiply.js","../src/operations/array/filter.js","../src/operations/array/map.js","../src/operations/array/reduce.js","../src/createJsonLogic.js","../src/index.js","../src/operations/array/merge.js","../src/helpers/uses_data.js","../src/helpers/arrayUnique.js"],"sourcesContent":["function add(...args) {\n  return args.reduce((a, b) => parseFloat(a, 10) + parseFloat(b, 10), 0);\n}\n\nadd.op = '+';\n\nexport default add;\n","function multiply(...args) {\n  return args.reduce((a, b) => parseFloat(a, 10) * parseFloat(b, 10), 1);\n}\n\nmultiply.op = '*';\n\nexport default multiply;\n","import isArray from '../../helpers/isArray';\nimport truthy from '../../helpers/truthy';\n\nfunction filter(apply, data, values) {\n  const scopedData = apply(values[0], data);\n  const scopedLogic = values[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n  // Return only the elements from the array in the first argument,\n  // that return truthy when passed to the logic in the second argument.\n  // For parity with JavaScript, reindex the returned array\n  return scopedData.filter(datum => truthy(apply(scopedLogic, datum)));\n}\n\nfilter.deepFirst = false;\n\nexport default filter;\n","import isArray from '../../helpers/isArray';\n\nfunction map(apply, data, values) {\n  const scopedData = apply(values[0], data);\n  const scopedLogic = values[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n\n  return scopedData.map(datum => apply(scopedLogic, datum));\n}\n\nmap.deepFirst = false;\n\nexport default map;\n","import isArray from '../../helpers/isArray';\n\nfunction reduce(apply, data, values) {\n  const scopedData = apply(values[0], data);\n  const scopedLogic = values[1];\n  const initial = typeof values[2] !== 'undefined' ? values[2] : null;\n\n  if (!isArray(scopedData)) {\n    return initial;\n  }\n\n  return scopedData.reduce(\n    (accumulator, current) => apply(scopedLogic, { current, accumulator }),\n    initial\n  );\n}\n\nreduce.deepFirst = false;\n\nexport default reduce;\n","import isArray from './helpers/isArray';\nimport is_logic from './helpers/is_logic';\nimport get_operator from './helpers/get_operator';\n\nfunction createJsonLogic(_operations) {\n  const operations = {};\n\n  if (_operations) {\n    Object.keys(_operations).forEach(name => {\n      const operation = _operations[name];\n\n      add_operation(operation.op || name, operation);\n    });\n  }\n\n  function add_operation(name, op) {\n    if (isArray(name)) {\n      name.forEach(key => add_operation(key, op));\n      return;\n    }\n\n    operations[name] = op;\n  }\n\n  function rm_operation(name) {\n    if (isArray(name)) {\n      name.forEach(key => rm_operation(key));\n      return;\n    }\n\n    delete operations[name];\n  }\n\n  function apply(logic, data = {}) {\n    // Does this array contain logic? Only one way to find out.\n    if (isArray(logic)) {\n      return logic.map(l => apply(l, data));\n    }\n    // You've recursed to a primitive, stop!\n    if (!is_logic(logic)) {\n      return logic;\n    }\n\n    const op = get_operator(logic);\n    let values = logic[op];\n    let i;\n\n    // easy syntax for unary operators, like {\"var\" : \"x\"} instead of strict {\"var\" : [\"x\"]}\n    if (!isArray(values)) {\n      values = [values];\n    }\n\n    const operator = operations[op];\n    if (typeof operator === 'function') {\n      const { deepFirst = true } = operator;\n\n      // apply matching visitors first\n      if (!deepFirst) {\n        return operator(apply, data, values);\n      }\n    }\n\n    // Everyone else gets immediate depth-first recursion\n    values = values.map(val => apply(val, data));\n\n    // The operation is called with \"data\" bound to its \"this\" and \"values\" passed as arguments.\n    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n    if (typeof operator === 'function') {\n      const { withApply } = operator;\n\n      if (withApply) {\n        values.unshift(apply);\n      }\n\n      return operator.apply(data, values);\n    }\n\n    if (op.indexOf('.') > 0) {\n      // Contains a dot, and not in the 0th position\n      const sub_ops = String(op).split('.');\n      let operation = operations;\n      for (i = 0; i < sub_ops.length; i++) {\n        // Descending into operations\n        operation = operation[sub_ops[i]];\n        if (operation === undefined) {\n          throw new Error(\n            `Unrecognized operation ${op} (failed at ${sub_ops\n              .slice(0, i + 1)\n              .join('.')})`\n          );\n        }\n      }\n\n      return operation.apply(data, values);\n    }\n\n    throw new Error(`Unrecognized operation ${op}`);\n  }\n\n  return {\n    apply,\n    add_operation,\n    rm_operation,\n  };\n}\n\nexport default createJsonLogic;\n","import createJsonLogic from './createJsonLogic';\nimport * as operations from './operations';\nimport is_logic from './helpers/is_logic';\nimport truthy from './helpers/truthy';\nimport get_operator from './helpers/get_operator';\nimport get_values from './helpers/get_values';\nimport uses_data from './helpers/uses_data';\nimport rule_like from './helpers/rule_like';\n\nconst jsonLogic = createJsonLogic(operations);\n\n// restore original public API\njsonLogic.is_logic = is_logic;\njsonLogic.truthy = truthy;\njsonLogic.get_operator = get_operator;\njsonLogic.get_values = get_values;\njsonLogic.uses_data = uses_data;\njsonLogic.rule_like = rule_like;\n\nexport default jsonLogic;\n","function merge(...args) {\n  return args.reduce((a, b) => a.concat(b), []);\n}\n\nexport default merge;\n","import isArray from './isArray';\nimport is_logic from './is_logic';\nimport get_operator from './get_operator';\nimport arrayUnique from './arrayUnique';\n\nfunction uses_data(logic) {\n  const collection = [];\n\n  if (is_logic(logic)) {\n    const op = get_operator(logic);\n    let values = logic[op];\n\n    if (!isArray(values)) {\n      values = [values];\n    }\n\n    if (op === 'var') {\n      // This doesn't cover the case where the arg to var is itself a rule.\n      collection.push(values[0]);\n    } else {\n      // Recursion!\n      values.forEach(val => {\n        collection.push(...uses_data(val));\n      });\n    }\n  }\n\n  return arrayUnique(collection);\n}\n\nexport default uses_data;\n","/**\n * Return an array that contains no duplicates (original not modified)\n * @param  {array} array   Original reference array\n * @return {array}         New array with no duplicates\n */\nfunction arrayUnique(array) {\n  const a = [];\n  for (let i = 0, l = array.length; i < l; i++) {\n    if (a.indexOf(array[i]) === -1) {\n      a.push(array[i]);\n    }\n  }\n  return a;\n}\n\nexport default arrayUnique;\n"],"names":["createJsonLogic","arrayUnique"],"mappings":"69CACqB,CAAA,uNCAA,CAAA,gVCYM,CAAA,8FCHH,CAAA,4KCEpB,CAAA,kmCCRJ,CAAA,oDAamB,CAAA,qEATkB,CAAA,iJA4Bd,CAAA,oLA2BC,CAAA,gbArCL,CAAA,yCCjBDA,CAAAA,iOCRG,CAAA,+xBCoBA,CAAA,8CChBrB,CAAA,4FDsBSC,CAAAA"}